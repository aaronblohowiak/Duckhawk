<html>
<head>
    <style type="text/css">
        body {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            font-weight: 300;
            font-size: 12px;
            margin: 0;
            padding: 0 00px;
            width: 100%;
        }

        .trace,
        .trace-node-wrapper,
        .trace-cascade,
        .trace-viewport,
        .trace-contain-everything
        {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            border-radius: 4px;
        }

        .trace-contain-everything {
            /* EVERYTHING in the trace itself. multiple per-page */
        }

        .trace-viewport {
            overflow: scroll;
            position: relative;
            top: 100px;
        }

        .trace-cascade {
            /* The visualization of the nodes in the trace. */
            width: 100%;
            margin: 0 auto;
            overflow: hidden;
        }

        .trace-node-wrapper {
            /* Wraps the trace AND all of its children.
                the width of this element is equal to the duration as a percentage of its parent's duration 
            Duration: distance from the earliest observed time of any of its childen to the latest observed time of any of its children. Take special care that children may end after their parent, or begin before their parent. Time in networks is weird.
            */
            clear: right;
            margin: 2px 0px;
            border: 1px solid rgba(0,0,0,0.2);

        }

        .trace {
            /* an individual span */
            /* margin-left: x%; the start time */
            /* width: y%; the duration as a percentage of the duration of the parent */
            border: 0;
            white-space: nowrap;
            padding-left : 0.5em;
        }

        .trace-cascade.trace-preview{
            width: 100%;
            position: relative;
            height: 100px;
            position: fixed;
            top: 0;
            background-color: white;
            z-index:100;
        }

        .trace-cascade.trace-preview .trace-node-wrapper,
        .trace-cascade.trace-preview .trace{
            height: 4px;
            border: 0;
            color: rgba(0,0,0,0);
            margin: 0;

        }

        .trace-cascade.trace-preview .trace {
            background-color: rgba(0,0,0,0.3);
            padding: 0;
        }

        .trace-preview-blocker{
            position: absolute;
            background-color: rgba(0,0,0,0.2);
            height: 100%;
            top: 0;
        }

    </style>

    <style type="text/css">
        /* TESTING STYLES */
        .trace-contain-everything {
            background-color: black;
        }

        .trace-node-wrapper {
            background-color: rgba(255,255,255,0.07);
        }

        .trace {
            background-color: #1a8cff;
            color: white;
            height: 20px;
        }

        .trace-viewport {
            background-color: black;
            border: 1px solid #000;
            border-radius: 0;
        }

    </style>
</head>

<body>
  <div class="trace-contain-everything">
      <div class="trace-cascade trace-preview">
      </div>
    <div class="trace-viewport">
      <div class="trace-cascade">
      </div>
    </div>
</div>

<script type="text/javascript" src="//code.jquery.com/jquery-2.1.1.min.js"></script>
<script>
    window.onhashchange = function(){
        console.log(window.location.hash)
    }


    var cascade = $('.trace-viewport > .trace-cascade');
    var viewport = $('.trace-viewport');


    //pass in the start/stop as a percentage (0.20 for 20%) of total
    // set the width and zoom of the viewport to match
    function updateViewingWindow(start, stop){
        //set the width.
        var percentToCover = stop - start;
        var zoomRatio = 1 / percentToCover;
        var newWidth = 100 * zoomRatio; // css width is "200%"" not "2"


        cascade.css({width: newWidth+"%"});
        var cascadeWidth = cascade.width();
        viewportWidthPercent = stop - start;
        viewport.scrollLeft(cascadeWidth * start);
    }

    function highlight(start, stop){
        console.log(start, stop)
        leftBox.css({
            width: (start * 100)+"%"
        })

        rightBox.css({
            width: ((1 - stop) * 100 + "%"),
            right: 0
        })
    }

    function viewportChanged(){
        var cascadeWidth = cascade.width();
        var viewportWidth = viewport.width();

        var scrollLeft = viewport.scrollLeft();

        var start = scrollLeft / cascadeWidth;
        var stop = start + (viewportWidth / cascadeWidth);
        highlight(start, stop);
        return true;
    }

    viewport.scroll(viewportChanged);

    var resizingWindow;
    $(window).resize(function(){
      viewportChanged()
      // clearTimeout(resizingWindow);
      // resizingWindow = setTimeout(viewportChanged, 10);
    });

    $(document).keyup(function(e) {
        if(e.keyCode == 27){
            highlight(0, 100);
            updateViewingWindow(0, 1);
        }
    });

    var preview = $('.trace-cascade.trace-preview');

    var leftBox = $('<div class="trace-preview-blocker"></div>');
    var rightBox = $('<div class="trace-preview-blocker"></div>');
    preview.append(leftBox);
    preview.append(rightBox);

    (function() {
        var selecting = false;
        var startOffset;
        var currentOffset;

        preview.mousedown(function(event){
            selecting = true;
            startOffset = event.pageX;
            currentOffset = startOffset;
            return false
        });

        preview.mousemove(function(event){
            if(selecting){
                currentOffset = event.pageX;
                updateSelectedRegion()
            }
            return false
        });

        preview.mouseup(function(event){
            stopSelectingPreview();
        })

        function stopSelectingPreview(){
            selecting = false;
            updateSelectedRegion()
        }

        function updateSelectedRegion(){
            var selectionStart = Math.min(startOffset, currentOffset);
            var selectionStop = Math.max(startOffset, currentOffset);

            var previewWidth = preview.width();
            start = selectionStart/previewWidth;
            stop = selectionStop/previewWidth;
            updateViewingWindow(start, stop);
        }
    })();


    // The Tree is a K-ary tree of Wrappers and Traces
    // A Trace has a min and a max
    // A wrapper may have a single Trace, a non-empty array children or both.
    // A wrapper has an array of wrappers, its children.
    // The min of a Wrapper is the lesser of its Trace min and the min of its children.
    // The max of a wrapper is the greater of its Trace max and the max of its children.
    // The children of a Wrapper are sorted by min

    //wrap each Trace in a wrapper
    // build a hash from Trace id to wrapper. If a wrapper and a trace already exist in the hash, merge the Traces and wrappers.
    // For each wrapper, if its Trace's parent_id is in the hash, append the Trace to the children of the wrapper. Otherwise, generate a wrapper for the parent_id, add it to the hash, add the current wrapper to the new one's children and append the new wrapper to the children of the Root.
    // Sort the children of the root. For each child, sort its children, recursively.
    // generate the preview and the cascade.
    function Wrapper(trace){
      this.trace = trace;
      this.children = [];
    }

    Wrapper.prototype.min = function(cacheOk) {
      if(cacheOk && this._min){
        return this._min
      }

      var minChildren
      if(this.children.length > 0 ){
        minChildren = Math.min.apply(Math, $.map(this.children, function(child){return child.min(cacheOk)}));
      }else{
        minChildren = Infinity
      }

      if(this.trace && this.trace.start){
        return this._min = Math.min(minChildren, this.trace.start)
      }else{
        return this._min = minChildren;
      }
    }

    //TODO: handle if max or min are Infinity or -Infinity (missing trace info)
    Wrapper.prototype.duration = function(cacheOk){
      return (this.max(cacheOk) - this.min(cacheOk))
    }

    Wrapper.prototype.max = function(cacheOk) {
      if(cacheOk && this._max){
        return this._max
      }

      var maxChildren
      if(this.children.length > 0 ){
        maxChildren = Math.max.apply(Math, $.map(this.children, function(child){return child.max(cacheOk)}));
      }else{
        maxChildren = -1 * Infinity
      }

      if(this.trace && this.trace.finish){
        return this._max = Math.max(maxChildren, this.trace.finish)
      }else{
        return this._max = maxChildren;
      }
    }

    Wrapper.prototype.merge = function(trace) {
      if(this.trace){
        console.log("merge?", this, trace)  
      }else {
        this.trace = trace;
        console.log("MERGED", trace.id)
      }
    }

    Wrapper.prototype.sort = function(cacheOk){
      if(cacheOk){
        this.children.sort(Wrapper.compareCached);  
      }else{
        throw("Not Implemented");
      }

      for (var i = this.children.length - 1; i >= 0; i--) {
        this.children[i].sort(cacheOk);
      };
    }

    Wrapper.compareCached = function (b, a) {
      if (a.min(true) < b.min(true))
         return -1;
      if (a.min(true) > b.min(true))
         return 1;
      return 0;
    }

    function add(trace, wrappers, root){
      console.log("SEEN", trace.id )

      var existing = wrappers[trace.id];
      if(existing){
        existing.merge(trace);
        return existing;
      }

      var myWrapper = new Wrapper(trace);
      wrappers[trace.id] = myWrapper
    }

    function process(trace, wrappers, root){
      if(!trace.parent_id){
        root.children.push(wrappers[trace.id]);
        return
      }

      var parent = wrappers[trace.parent_id];
      if(!parent){
        console.log("MISSING", trace.parent_id )
        parent = new Wrapper();
        wrappers[trace.parent_id] = parent;
        root.children.push(parent);
      }

      parent.children.push(wrappers[trace.id]);

      return wrappers[trace.id];
    }

    var wrappers = {};
    var root = new Wrapper()
    $.get('/data?id=' + window.location.hash.replace('#', ''), function(data){
      data = JSON.parse(data)

      for (var i = data.length - 1; i >= 0; i--) {
        add(data[i], wrappers, root)
      };

      for (var i = data.length - 1; i >= 0; i--) {
        process(data[i], wrappers, root)
      };

      cascade.data({min: root.min(), max: root.max(), duration: root.duration()});
      root.sort(true)

      render(root, cascade);
      render(root, preview);
    });

    //note: before this fn is called on root, the max and min must be called and the children must be sorted.
    function render(wrapper, parentElm){
      var wrapperElm = $('<div class="trace-node-wrapper"></div>');
      var duration = wrapper.duration(true);
      var width = ((duration / parentElm.data()['duration']) * 100) + "%";
      var left = (wrapper.min(true) - parentElm.data()['min']) / parentElm.data()['duration'];


      wrapperElm.css({
        width: width,
        marginLeft: (left * 100) + "%"
      }).data({
        wrapper: wrapper,
        max: wrapper.max(true),
        min: wrapper.min(true),
        duration: duration
      });

      if(wrapper.trace){
        var trace = wrapper.trace;
        duration = trace.finish - trace.start;

        var traceElm = $(document.createElement('div'));
        traceElm.addClass('trace');
        traceElm.css({
          width: ((duration / wrapperElm.data()['duration']) * 100) + "%"
        }).data({
          trace: trace
        });
        wrapperElm.append(traceElm);

        var about = $(document.createElement('div'));
        traceElm.addClass('about');

        var ms = Math.round((trace.finish - trace.start) * 10000) / 10 ;

        var what;

        if(trace.payload) {
          what = (trace.payload && trace.payload.url || trace.payload.path || "");
          if(trace.payload.request){
            what += " " + trace.payload.request.host;
          }
        }

        about.html(trace.tag + " &nbsp;" + ms + "ms " + what + "")
        about.data({
          trace: trace
        });
        traceElm.append(about)
      }

      for (var i = wrapper.children.length - 1; i >= 0; i--) {
        render(wrapper.children[i], wrapperElm);
      }

      parentElm.append(wrapperElm);
      return wrapperElm;
    }

    /* https://github.com/samdutton/simpl/blob/master/postmessage/popup/js/other.js */

    $('.trace-viewport').on('click', 'div.trace', function(e){
      console.log(e)
      trace = $(e.target).data('trace');

      var newWindow = window.open("","","width="+(preview.width() * 0.6)+",height=600,scrollbars=1,resizable=1")

      //read text from textbox placed in parent window
      var text = JSON.stringify(trace, null, 2)
      var tmpElm = $('<div id="editor"></div>')
      tmpElm.text(text);
      text = tmpElm.html()

      var html = "<html><head></head><body><pre>"+ text +"</pre>"
      html += "</body></html>"

      newWindow .document.open()
      newWindow .document.write(html)
      newWindow .document.close()

    })
</script>
</body>
</html>
